import{as as N,al as nt,bu as ot,cx as K,cy as Z,aZ as rt,B as it,cz as lt}from"./index-LSfb4K_5.js";const U=()=>nt.getLogger("esri.views.2d.engine.flow.dataUtils"),st=10;async function gt(m,t,o,u){const d=performance.now(),g=at(t,o),c=performance.now(),s=ft(t,g,o.width,o.height),e=performance.now(),n=ut(s),r=performance.now(),M=m==="Streamlines"?dt(n,st):wt(n),A=performance.now();return N("esri-2d-profiler")&&(U().info("I.1","_createFlowFieldFromData (ms)",Math.round(c-d)),U().info("I.2","_getStreamlines (ms)",Math.round(e-c)),U().info("I.3","createAnimatedLinesData (ms)",Math.round(r-e)),U().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(A-r)),U().info("I.5","createFlowMesh (ms)",Math.round(A-d)),U().info("I.6","Mesh size (bytes)",M.vertexData.buffer.byteLength+M.indexData.buffer.byteLength)),await Promise.resolve(),ot(u),M}function at(m,t){const o=ht(t.data,t.width,t.height,m.smoothing);return m.interpolate?(u,d)=>{const g=Math.floor(u),c=Math.floor(d);if(g<0||g>=t.width)return[0,0];if(c<0||c>=t.height)return[0,0];const s=u-g,e=d-c,n=g,r=c,M=g<t.width-1?g+1:g,A=c<t.height-1?c+1:c,i=o[2*(r*t.width+n)],f=o[2*(r*t.width+M)],x=o[2*(A*t.width+n)],v=o[2*(A*t.width+M)],y=o[2*(r*t.width+n)+1],h=o[2*(r*t.width+M)+1];return[(i*(1-e)+x*e)*(1-s)+(f*(1-e)+v*e)*s,(y*(1-e)+o[2*(A*t.width+n)+1]*e)*(1-s)+(h*(1-e)+o[2*(A*t.width+M)+1]*e)*s]}:(u,d)=>{const g=Math.round(u),c=Math.round(d);return g<0||g>=t.width||c<0||c>=t.height?[0,0]:[o[2*(c*t.width+g)],o[2*(c*t.width+g)+1]]}}function W(m,t,o,u,d,g,c,s){const e=[],{raster:n,width:r,height:M,resolutionFactor:A}=s;let i=u,f=d,x=0,[v,y]=o(i,f);v*=t.velocityScale,y*=t.velocityScale;const h=Math.sqrt(v*v+y*y);let p,w;e.push({x:i,y:f,t:x,speed:h});for(let l=0;l<t.verticesPerLine;l++){let[a,D]=o(i,f);a*=t.velocityScale,D*=t.velocityScale;const F=Math.sqrt(a*a+D*D);if(F<t.minSpeedThreshold)return e;const L=m*a/F,_=m*D/F;if(i+=L*t.segmentLength,f+=_*t.segmentLength,t.wrapAround&&(i=Z(i,g[0])),x+=m*t.segmentLength/F,Math.acos(L*p+_*w)>t.maxTurnAngle)return e;if(t.collisions){let P=Math.round(i*A);const S=Math.round(f*A);if(t.wrapAround&&(P=Z(P,r)),P<0||P>r-1||S<0||S>M-1)return e;const B=n[S*r+P];if(B!==-1&&B!==c)return e;n[S*r+P]=c}e.push({x:i,y:f,t:x,speed:F}),p=L,w=_}return e}function ct(m,t,o,u,d,g,c,s){const e=Math.round((.2+.6*c.getFloat())*m.verticesPerLine),n=m.verticesPerLine-e,r=W(-1,{...m,verticesPerLine:n},t,o,u,d,g,s),M=W(1,{...m,verticesPerLine:e},t,o,u,d,g,s),A=r.reverse();return A.splice(-1,1),A.concat(M)}function ft(m,t,o,u,d={positions:[]}){if(m.density<=0)return[];const{positions:g}=d,c=[],s=new K,e=1/Math.max(m.lineCollisionWidth,1),n=Math.round(o*e),r=Math.round(u*e),M=new Int32Array(n*r);for(let h=0;h<M.length;h++)M[h]=-1;const A={raster:M,width:n,height:r,resolutionFactor:e},i={},f=m.lineSpacing/Math.sqrt(m.density),x=Math.floor(u/f),v=Math.floor(o/f);for(let h=0;h<x;h++){const p=h*f;for(let w=0;w<v;w++){const l=w*f;i[`${w}-${h}`]={x:l,y:p,positions:[]}}}for(const{x:h,y:p}of g){const w=i[`${Math.floor(h/f)}-${Math.floor(p/f)}`];w&&w.positions.push([h,p])}const y=[];for(const h in i){const p=i[h];if(p.positions.length===0)y.push({x:p.x+f/2,y:p.y+f/2,sort:.66+.33*s.getFloat(),stage:0});else{const[w]=p.positions.splice(0,1);y.push({x:w[0],y:w[1],sort:.33*s.getFloat(),stage:1});for(const[l,a]of p.positions)y.push({x:l,y:a,sort:.33+.33*s.getFloat(),stage:2})}}y.sort((h,p)=>h.sort-p.sort);for(const{x:h,y:p,stage:w}of y){const l=m.onlyForwardTracing?W(1,m,t,h,p,[o,u],c.length,A):ct(m,t,h,p,[o,u],c.length,s,A);l.length<2||c.push({stage:w,vertices:l})}return c}function ht(m,t,o,u){if(u===0)return m;const d=Math.round(3*u),g=new Array(2*d+1);let c=0;for(let n=-d;n<=d;n++){const r=Math.exp(-n*n/(u*u));g[n+d]=r,c+=r}for(let n=-d;n<=d;n++)g[n+d]/=c;const s=new Float32Array(m.length);for(let n=0;n<o;n++)for(let r=0;r<t;r++){let M=0,A=0;for(let i=-d;i<=d;i++){if(r+i<0||r+i>=t)continue;const f=g[i+d];M+=f*m[2*(n*t+(r+i))],A+=f*m[2*(n*t+(r+i))+1]}s[2*(n*t+r)]=M,s[2*(n*t+r)+1]=A}const e=new Float32Array(m.length);for(let n=0;n<t;n++)for(let r=0;r<o;r++){let M=0,A=0;for(let i=-d;i<=d;i++){if(r+i<0||r+i>=o)continue;const f=g[i+d];M+=f*s[2*((r+i)*t+n)],A+=f*s[2*((r+i)*t+n)+1]}e[2*(r*t+n)]=M,e[2*(r*t+n)+1]=A}return e}function ut(m,t){const o=new K,u=m.reduce((e,n)=>e+n.vertices.length,0),d=new Float32Array(4*u),g=new Array(m.length);let c=0,s=0;for(const{vertices:e}of m){const n=c;for(const r of e)d[4*c]=r.x,d[4*c+1]=r.y,d[4*c+2]=r.t,d[4*c+3]=r.speed,c++;g[s++]={startVertex:n,numberOfVertices:e.length,totalTime:e[e.length-1].t,timeSeed:o.getFloat()}}return{lineVertices:d,lineDescriptors:g}}function dt(m,t){const{lineVertices:u,lineDescriptors:d}=m;let g=0,c=0;for(const i of d)g+=2*i.numberOfVertices,c+=6*(i.numberOfVertices-1);const s=new Float32Array(g*9),e=new Uint32Array(c);let n=0,r=0;function M(){e[r++]=n-2,e[r++]=n,e[r++]=n-1,e[r++]=n,e[r++]=n+1,e[r++]=n-1}function A(i,f,x,v,y,h,p,w){const l=n*9;let a=0;s[l+a++]=i,s[l+a++]=f,s[l+a++]=1,s[l+a++]=x,s[l+a++]=h,s[l+a++]=p,s[l+a++]=v/2,s[l+a++]=y/2,s[l+a++]=w,n++,s[l+a++]=i,s[l+a++]=f,s[l+a++]=-1,s[l+a++]=x,s[l+a++]=h,s[l+a++]=p,s[l+a++]=-v/2,s[l+a++]=-y/2,s[l+a++]=w,n++}for(const i of d){const{totalTime:f,timeSeed:x}=i;let v=null,y=null,h=null,p=null,w=null,l=null;for(let a=0;a<i.numberOfVertices;a++){const D=u[4*(i.startVertex+a)],F=u[4*(i.startVertex+a)+1],L=u[4*(i.startVertex+a)+2],_=u[4*(i.startVertex+a)+3];let P=null,S=null,B=null,j=null;if(a>0){P=D-v,S=F-y;const V=Math.sqrt(P*P+S*S);if(P/=V,S/=V,a>1){let I=P+w,b=S+l;const k=Math.sqrt(I*I+b*b);I/=k,b/=k;const R=Math.min(1/(I*P+b*S),t);I*=R,b*=R,B=-b,j=I}else B=-S,j=P;B!==null&&j!==null&&(A(v,y,h,B,j,f,x,_),M())}v=D,y=F,h=L,w=P,l=S,p=_}A(v,y,h,-l,w,f,x,p)}return{vertexData:s,indexData:e}}function wt(m){const{lineVertices:d,lineDescriptors:g}=m;let c=0,s=0;for(const V of g){const I=V.numberOfVertices-1;c+=4*I*2,s+=6*I*2}const e=new Float32Array(c*16),n=new Uint32Array(s);let r,M,A,i,f,x,v,y,h,p,w,l,a,D,F=0,L=0;function _(){n[L++]=F-8,n[L++]=F-7,n[L++]=F-6,n[L++]=F-7,n[L++]=F-5,n[L++]=F-6,n[L++]=F-4,n[L++]=F-3,n[L++]=F-2,n[L++]=F-3,n[L++]=F-1,n[L++]=F-2}function P(V,I,b,k,R,C,O,z,E,G,Q,X,Y,$){const q=F*16;let T=0;for(const tt of[1,2])for(const et of[1,2,3,4])e[q+T++]=V,e[q+T++]=I,e[q+T++]=b,e[q+T++]=k,e[q+T++]=O,e[q+T++]=z,e[q+T++]=E,e[q+T++]=G,e[q+T++]=tt,e[q+T++]=et,e[q+T++]=Y,e[q+T++]=$,e[q+T++]=R/2,e[q+T++]=C/2,e[q+T++]=Q/2,e[q+T++]=X/2,F++}function S(V,I){let b=h+w,k=p+l;const R=Math.sqrt(b*b+k*k);b/=R,k/=R;const C=h*b+p*k;b/=C,k/=C;let O=w+a,z=l+D;const E=Math.sqrt(O*O+z*z);O/=E,z/=E;const G=w*O+l*z;O/=G,z/=G,P(r,M,A,i,-k,b,f,x,v,y,-z,O,V,I),_()}function B(V,I,b,k,R,C){if(h=w,p=l,w=a,l=D,h==null&&p==null&&(h=w,p=l),f!=null&&x!=null){a=V-f,D=I-x;const O=Math.sqrt(a*a+D*D);a/=O,D/=O}h!=null&&p!=null&&S(R,C),r=f,M=x,A=v,i=y,f=V,x=I,v=b,y=k}function j(V,I){h=w,p=l,w=a,l=D,h==null&&p==null&&(h=w,p=l),h!=null&&p!=null&&S(V,I)}for(const V of g){r=null,M=null,A=null,i=null,f=null,x=null,v=null,y=null,h=null,p=null,w=null,l=null,a=null,D=null;const{totalTime:I,timeSeed:b}=V;for(let k=0;k<V.numberOfVertices;k++)B(d[4*(V.startVertex+k)],d[4*(V.startVertex+k)+1],d[4*(V.startVertex+k)+2],d[4*(V.startVertex+k)+3],I,b);j(I,b)}return{vertexData:e,indexData:n}}function H(m,t,o=t.width,u=t.height,d=0,g=0){const c=t.pixels,s=o*u,e=2,n=new Float32Array(s*e),r=t.width,M=(f,x)=>f+d+(x+g)*r,A=(f,x)=>f+x*o;let i;if(t.mask!=null)if(o!==t.width||u!==t.height||d!==0||g!==0){i=new Uint8Array(s*e);const f=t.mask;for(let x=0;x<u;++x)for(let v=0;v<o;++v){const y=M(v,x),h=A(v,x);i[e*h]=f[e*y],i[e*h+1]=f[e*y+1]}}else i=t.mask;else i=new Uint8Array(s*e),i.fill(255);if(m==="vector-uv")for(let f=0;f<u;++f)for(let x=0;x<o;++x){const v=M(x,f),y=A(x,f);n[e*y]=c[0][v],n[e*y+1]=-c[1][v]}else if(m==="vector-magdir"){const{cos:f,sin:x}=Math;for(let v=0;v<u;++v)for(let y=0;y<o;++y){const h=M(y,v),p=A(y,v),w=c[0][h],l=lt(c[1][h]),a=f(l-Math.PI/2),D=x(l-Math.PI/2);n[e*p]=a*w,n[e*p+1]=D*w}}return{data:n,mask:i,width:o,height:u}}async function pt(m,t,o,u,d,g){const c=performance.now(),s=rt(t.spatialReference);if(!s){const w=await J(m,t,o,u,d,g);return N("esri-2d-profiler")&&U().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-c)),N("esri-2d-profiler")&&U().info("I.9","Number of parts",1),w}const[e,n]=s.valid,r=n-e,M=Math.ceil(t.width/r),A=t.width/M,i=Math.round(o/M);let f=t.xmin;const x=[],v=performance.now();for(let w=0;w<M;w++){const l=new it({xmin:f,xmax:f+A,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference});x.push(J(m,l,i,u,d,g)),f+=A}const y=await Promise.all(x);if(N("esri-2d-profiler")&&U().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-v)),N("esri-2d-profiler")&&U().info("I.9","Number of parts",y.length),y.length===1)return N("esri-2d-profiler")&&U().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-c)),y[0];const h={data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u};let p=0;for(const w of y){for(let l=0;l<w.height;l++)for(let a=0;a<w.width;a++)p+a>=o||(h.data[2*(l*o+p+a)]=w.data[2*(l*w.width+a)],h.data[2*(l*o+p+a)+1]=w.data[2*(l*w.width+a)+1],h.mask[l*o+p+a]=w.mask[l*w.width+a]);p+=w.width}return N("esri-2d-profiler")&&U().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-c)),h}async function J(m,t,o,u,d,g){const c={requestProjectedLocalDirections:!0,signal:g};if(d!=null&&(c.timeExtent=d),m.type==="imagery"){await m.load({signal:g});const e=await m.internalFetchImage(t,o,u,c);return e?.pixelData?.pixelBlock==null?{data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u}:H(m.rasterInfo.dataType,e.pixelData.pixelBlock)}await m.load({signal:g});const s=await m.fetchPixels(t,o,u,c);return s?.pixelBlock==null?{data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u}:H(m.serviceRasterInfo.dataType,s.pixelBlock)}export{gt as c,ft as d,at as f,pt as x};
